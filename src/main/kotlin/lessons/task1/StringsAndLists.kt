package lessons.task1

import kotlin.math.pow
import kotlin.math.sqrt

// СПИСКИ

/*
  РАСПРОСТРАНЕННЫЕ ОПЕРАЦИИ НАД СПИСКАМИ

  listOf(...) - создание нового списка.

  list1 + list2 - сложение двух списков, сумма списков содержит все элементы их обоих.

  list + element - сложение списка и элемента, сумма содержит все элементы list и дополнительно element

  list.size - получение размера списка (Int).

  list.isEmpty(), list.isNotEmpty() - получение признаков пустоты и непустоты списка (Boolean).

  list[i] - индексация, то есть получение __элемента__ списка с целочисленным __индексом__ (номером) i.
      По правилам Котлина, в списке из n элементов они имеют индексы, начинающиеся с нуля: 0, 1, 2, ...,
      последний элемент списка имеет индекс n - 1. То есть, при использовании записи list[i] должно быть
      справедливо i >= 0 && i < list.size. В противном случае выполнение программы будет прервано с ошибкой
      (использование индекса за пределами границ списка).

  list.sublist(from, to) - создание списка меньшего размера (подсписка), в который войдут элементы списка list
      с индексами from, from + 1, ..., to - 2, to - 1. Элемент с индексом to не включается.

  element in list - проверка принадлежности элемента element списку list.

  for (element in list) { ... } - цикл **for**, перебирающий все элементы списка list.

  list.first() - получение первого элемента списка (если список пуст, выполнение программы будет прервано с ошибкой).

  list.last() - получение последнего элемента списка (аналогично).

  list.indexOf(element) - поиск индекса элемента element в списке list.
      Результат этой функции равен -1, если элемент в списке отсутствует.
      В противном случае, при обращении к списку list по вычисленному индексу мы получим element.

  list.min(), list.max() - поиск минимального и максимального элемента в списке.

  list.sum() - сумма элементов в списке.

  list.sorted(), list.sortedDescending() - построение отсортированного списка
      (по возрастанию или по убыванию) из имеющегося.

  list1 == list2 - сравнение двух списков на равенство.
  Списки равны, если равны их размеры и соответствующие элементы.

 */

/*
  МУТИРУЮЩИЕ СПИКИ

  Мутирующий список является разновидностью обычного, его тип определяется как MutableList<ElementType>.
  В дополнение к тем возможностям, которые есть у всех списков в Котлине, мутирующий список может изменяться
  по ходу выполнения программы или функции. Это означает, что мутирующий список позволяет:

  1. Изменять своё содержимое операторами list[i] = element.

  2. Добавлять элементы в конец списка, с увеличением размера на 1: list.add(element).

  3. Удалять элементы из списка, с уменьшением размера на 1 (если элемент был в списке): list.remove(element).

  4. Удалять элементы из списка по индексу, с уменьшением размера на 1: list.removeAt(index).

  5. Вставлять элементы в середину списка: list.add(index, element)вставляет элемент element
        по индексу index, сдвигая все последующие элементы на 1, например listOf(1, 2, 3).add(1, 7)
        даст результат [1, 7, 2, 3].

  6. Для создания мутирующего списка можно использовать функцию mutableListOf(…), аналогичную listOf(…).

 */


/**
 * Пример
 *
 * Найти все корни уравнения x^2 = y
 */
fun sqRoots(y: Double) =
    when {
        y < 0 -> listOf()
        y == 0.0 -> listOf(0.0)
        else -> {
            val root = sqrt(y)
            // Результат!
            listOf(-root, root)
        }
    }
/**
 * Пример
 *
 * Найти все корни биквадратного уравнения ax^4 + bx^2 + c = 0.
 * Вернуть список корней (пустой, если корней нет)
 */
fun biRoots(a: Double, b: Double, c: Double): List<Double> {
    if (a == 0.0) {
        return if (b == 0.0) listOf()
        else sqRoots(-c / b)
    }
    val d = discriminant(a, b, c)
    if (d < 0.0) return listOf()
    if (d == 0.0) return sqRoots(-b / (2 * a))
    val y1 = (-b + sqrt(d)) / (2 * a)
    val y2 = (-b - sqrt(d)) / (2 * a)
    return sqRoots(y1) + sqRoots(y2)
}

/**
 * Пример
 *
 * Выделить в список отрицательные элементы из заданного списка
 */
fun negativeList(list: List<Int>): List<Int> {
    val result = mutableListOf<Int>()
    for (element in list) {
        if (element < 0) {
            result.add(element)
        }
    }
    return result
}

/**
 * Пример
 *
 * Изменить знак для всех положительных элементов списка
 */
fun invertPositives(list: MutableList<Int>) {
    for (i in 0 until list.size) {
        val element = list[i]
        if (element > 0) {
            list[i] = -element
        }
    }
    // заметь, что ретурна тут нет, поскольку если мы подаем мутабл объект, то меняться будет он в том месте кода, где мы его создали
    // то есть тут он приходит из тестов и меняется в функции
}


/**
 * Пример
 *
 * По имеющемуся списку целых чисел, например [3, 6, 5, 4, 9], построить строку с примером их суммирования:
 * 3 + 6 + 5 + 4 + 9 = 27 в данном случае.
 */
fun buildSumExample(list: List<Int>) = list.joinToString(separator = " + ", postfix = " = ${list.sum()}")


/**
 * Задача 1
 *
 * Перевести число, представленное цифровой строкой str,
 * из системы счисления с основанием base в десятичную.
 * Цифры более 9 представляются латинскими строчными буквами:
 * 10 -> a, 11 -> b, 12 -> c и так далее.
 * Например: str = "13c", base = 14 -> 250
 *
 * Использовать функции стандартной библиотеки, напрямую и полностью решающие данную задачу
 * (например, str.toInt(base)), запрещается.
 */
fun decimalFromString(str: String, base: Int): Int {
    val list = listOf('a', 'b', 'c', 'd', 'e', 'f')
    val test = mutableListOf<Char>()
    val reverse = str.reversed()
    var result = 0
    for (letter in reverse) {
        test.add(letter)
        result = (10 + list.indexOf(test[0]) * (base.toDouble()).pow(test.indexOf(test[0]))).toInt()
    }

}


/**
 * Задача 2
 *
 * Записать заданное натуральное число 1..999999 прописью по-русски.
 * Например, 375 = "триста семьдесят пять",
 * 23964 = "двадцать три тысячи девятьсот шестьдесят четыре"
 */
fun russian(n: Int): String {
    val numbers = listOf<List<String>>(listOf<String>("один", "два", "три", "четыре", "пять", "шесть", "семь", "восемь", "девять"),
        listOf<String>("десять", "двадцать", "тридцать", "сорок", "пятьдесят", "шестьдесят", "семьдесят", "восемьдесят", "девяносто"),
        listOf<String>("сто", "двести", "триста", "четыреста", "пятьсот", "шестьсот", "семьсот", "восемьсот", "девятьсот"),
        listOf<String>("одиннадцать", "двенадцать", "тринадцать", "четырнадцать", "пятнадцать", "шестнадцать", "семнадцать", "восемнадцать", "девятнадцать"))
    val strN = n.toString()
    var isNumberComplex = false
    val result = mutableListOf<String>()


    for ((index, digit) in strN.withIndex()) {
        val intDigit = digit.toInt()
        val listIndex = strN.length - 1 - index
        if (listIndex == 3) {
            if (isNumberComplex) {
                result.add("тысяч")
            }
            else {
                when (intDigit) {
                    0 -> result.add("тысяч")
                    1 -> result.add("одна тысяча")
                    2 -> result.add("две тысячи")
                    in 0..4 -> result.add(numbers[0][intDigit - 1] + " тысячи")
                    in 0..9 -> result.add(numbers[0][intDigit - 1] + " тысяч")
                }
            }
            isNumberComplex = false
        }
        when {
            (intDigit == 0) || (isNumberComplex) -> continue
            listIndex % 3 == 1 && intDigit == 1 && strN[index + 1].toInt() != 0 -> result.add(numbers[3][strN[index + 1].toInt() - 1])
            else -> result.add(numbers[listIndex % 3][intDigit - 1])
        }
    }
    return result.toString()
}


/*

  ЗНАЧЕНИЯ И ССЫЛКИ
  В Котлине существует два способа хранения переменных (параметров) в памяти JVM: хранение значений и хранение ссылок.
    В любом из этих способов для переменной выделяется ячейка памяти, размер которой зависит от типа переменной,
    но не превышает 8 байт.

  При хранении значений в эту ячейку помещается значение переменной - так обычно (строго говоря, не всегда) происходит
    с переменными целочисленного, вещественного и символьного типа. При изменении значения переменной изменяется и
    содержимое соответствующей ей ячейки.

  При хранении ссылок в ячейку переменной помещается ссылка, при этом значение (содержимое) переменной хранится в специальном участке памяти JVM — куче (heap). Каждому используемому участку памяти кучи соответствует определённый номер, и как раз этот номер и используется в качестве ссылки. То есть, при хранении ссылок для чтения значения переменной необходимо выполнить не одно, а два действия:

  прочитать номер участка в куче из ячейки переменной;

  по этому номеру обратиться к куче и прочитать значение переменной.

  Хранение ссылок используется для всех составных и нестандартных типов, в частности, для строк, массивов, списков.
  При изменении переменной в результате выполнения оператора вроде v = … изменяется ссылка. Например:

fun foo() {
    // [1, 2, 3] хранится в участке кучи с номером 1, a хранит номер 1
    val a = listOf(1, 2, 3)
    // [4, 5] хранится в участке кучи с номером 2, b хранит номер 2
    var b = listOf(4, 5)
    // Присваивание ссылок: b теперь хранит номер 1
    b = a
}

  Обратите внимание, что после выполнения трёх приведённых операторов в участке кучи с номером 2 хранится список [4, 5],
    но ни одна переменная не хранит ссылку на этот участок. Подобный участок через некоторое время будет найден и уничтожен
    специальной программой JVM - сборщиком мусора, он же Garbage Collector.

  Такие типы, как String или List, не предполагают возможность изменения содержимого переменной.
    Опять-таки при попытке выполнить оператор вида s = … изменится ссылка. Например:

fun foo() {
    // Alpha: участок с номером 1
    val a = "Alpha"
    // Beta: участок с номером 2
    var b = "Beta"
    // Тоже номер 2
    val c = b
    // Формируем Alpha + Beta = AlphaBeta: участок с номером 3
    b = a + b
}
  При сложении a и b будет создана новая строка AlphaBeta и размещена в участке памяти с номером 3.
    После этого номер 3 будет записан в переменную b. Отметьте, что c по-прежнему хранит номер 2, а a — номер 1.

  Особенно интересна ситуация с типом MutableList, который позволяет изменять и содержимое переменной тоже. Например:

fun foo() {
    // Участок с номером 1
    val a = mutableListOf(1, 2, 3)
    // Тоже номер 1
    val b = a
    // Изменение содержимого участка с номером 1: теперь это [1, 2, 5]
    b[2] = 5
    println(a[2]) // 5 (!)
}
  После выполнения оператора b[2] = 5 участок памяти с номером 1 будет хранить список [1, 2, 5].
    Поскольку в переменной a хранится тот же номер 1, то вывод на консоль a[2] приведёт к выводу числа 5,
    хотя раньше этот элемент списка хранил значение 3.

  Подобный принцип используют и функции, имеющие параметр с типом MutableList:

fun invertPositives(list: MutableList<Int>) {
    for (i in 0..list.size - 1) {
        val element = list[i]
        if (element > 0) {
            list[i] = -element
        }
    }
}

fun test() {
    // Участок номер 1
    val a = mutableListOf(1, -2, 3)
    invertPositives(a)
    println(a) // [-1, -2, -3]
}
  При вызове invertPositives номер 1 будет переписан из аргумента a в параметр list.
    После этого функция invertPositives изменит содержимое списка, используя данный номер,
    и вызов println(a) выведет [-1, -2, -3] на консоль.

  Таким образом, имея дело с типами, хранящимися по ссылке (чаще говорят проще — ссылочные типы),
    стоит различать действия со ссылками и действия со значениями. К примеру, присваивание name = … это всегда
    действие со ссылкой. С другой стороны, вызов функции вроде list.isEmpty() или индексация вроде
    list[i], list[j] = i — это действия с содержимым, причём, некоторые из этих действий только читают содержимое
    переменной, а некоторые другие — изменяют его.

  С учётом этого различия в Котлине определено две разных операции сравнения на равенство:
    уже известная нам == и новая ===. Операция a == b — это сравнение содержимого на равенство,
    которое обычно выполняется с помощью вызова функции a.equals(b). Операция a === b — это сравнение ссылок
    на равенство, для которого не имеет значения, одинаковое содержимое у переменных или нет, важно только,
    чтобы оно находилось в участке кучи с одинаковым номером. Например:

fun foo() {
    val a = listOf(1, 2)
    val b = listOf(1, 2)
    println(a == b) // true
    println(a === b) // false
}
  Здесь a и b имеют одно и то же содержимое, но находятся в участках кучи с разными номерами.
    Операция != обратна операции == (сравнение содержимого на неравенство), а операция !==,
    соответственно — обратна операции === (сравнение ссылок на неравенство).

  Важно также, что сравнение содержимого на равенство не реализовано для массивов Array,
  и поэтому для них операции == и === эквивалентны. Это одна из причин, по которой следует использовать списки
  вместо массивов, где это возможно. Пример:

fun foo() {
    val a = arrayOf(1, 2)
    val b = arrayOf(1, 2)
    println(a == b) // false (!)
    println(a === b) // false
}

 */



// СТРОКИ


/**
 * Пример
 *
 * Время представлено строкой вида "11:34:45", содержащей часы, минуты и секунды, разделённые двоеточием.
 * Разобрать эту строку и рассчитать количество секунд, прошедшее с начала дня.
 */
fun timeStrToSeconds(str: String): Int {
    val parts = str.split(":")
    var result = 0
    for (part in parts) {
        val number = part.toInt()
        result = result * 60 + number
    }
    return result
}

/**
 * Пример
 *
 * Дано число n от 0 до 99.
 * Вернуть его же в виде двухсимвольной строки, от "00" до "99"
 */
fun twoDigitStr(n: Int) = if (n in 0..9) "0$n" else "$n"

/**
 * Пример
 *
 * Дано seconds -- время в секундах, прошедшее с начала дня.
 * Вернуть текущее время в виде строки в формате "ЧЧ:ММ:СС".
 */
fun timeSecondsToStr(seconds: Int): String {
    val hour = seconds / 3600
    val minute = (seconds % 3600) / 60
    val second = seconds % 60
    return String.format("%02d:%02d:%02d", hour, minute, second)
}

/*
  Немного посянения за)) формат

  Первым аргументом функции является форматная строка. Это обычный строковый литерал (константа),
    в которой, однако, особый смысл несёт символ процента %. Этот символ вместе с несколькими последующими
    образует модификатор формата, который функцией String.format будет заменён на её следующий аргумент
    (hour для первого процента, minute для второго и second для третьего). В этом смысле модификаторы формата
    напоминают строковые шаблоны "$name", но они имеют большую мощность, так как позволяют выбрать ещё и
    формат подстановки аргумента в строку.

  Конкретно %02d означает "подставить в строку целое число, заняв НЕ МЕНЬШЕ двух (2) символов и заполнить НЕДОСТАЮЩИЕ
    символы (если число однозначное) нулём (0). Перечислим другие распространённые модификаторы формата:

  %d — подставить число типа Int;

  %3d — подставить число типа Int, заняв не меньше трёх позиций (пустые заполняются по умолчанию пробелами);

  %c — подставить символ;

  %s — подставить строку;

  %20s — подставить строку, заняв не меньше 20 позиций;

  %lf — подставить число типа Double в обычном формате;

  %le — подставить число типа Double в экспоненциальном формате вида 1.3e+4;

  %6.2lf — подставить число типа Double в обычном формате, заняв не меньше шести позиций и используя ровно два знака после запятой.


 */


/**
 * Пример: консольный ввод
 */
fun main() {
    println("Введите время в формате ЧЧ:ММ:СС")
    val line = readLine()
    if (line != null) {
        val seconds = timeStrToSeconds(line)
        if (seconds == -1) {
            println("Введённая строка $line не соответствует формату ЧЧ:ММ:СС")
        } else {
            println("Прошло секунд с начала суток: $seconds")
        }
    } else {
        println("Достигнут <конец файла> в процессе чтения строки. Программа прервана")
    }
}


/**
 * Задача 3
 *
 * Дата представлена строкой вида "15 июля 2016".
 * Перевести её в цифровой формат "15.07.2016".
 * День и месяц всегда представлять двумя цифрами, например: 03.04.2011.
 * При неверном формате входной строки вернуть пустую строку.
 *
 * Обратите внимание: некорректная с точки зрения календаря дата (например, 30.02.2009) считается неверными
 * входными данными.
 */
fun dateStrToDigit(str: String): String {
    val months = mapOf("января" to 1, "февраля" to 2, "марта" to 3, "апреля" to 4, "мая" to 5,
        "июня" to 6, "июля" to 7, "августа" to 8, "сентября" to 9, "октября" to 10, "ноября" to 11, "декабря" to 12,)

    val dateList = str.split(" ")
    return when {
        dateList[1] in months -> String.format("%02d.%02d.%02d", dateList[0], months[dateList[1]], dateList[2])
        else -> ""
    }
}


/**
 * Задача 4
 *
 * Дата представлена строкой вида "15.07.2016".
 * Перевести её в строковый формат вида "15 июля 2016".
 * При неверном формате входной строки вернуть пустую строку
 *
 * Обратите внимание: некорректная с точки зрения календаря дата (например, 30 февраля 2009) считается неверными
 * входными данными.
 */
fun dateDigitToStr(digital: String): String {
    val months = mapOf("01" to "января" , "02" to "февраля", "03" to "марта", "04" to "апреля", "05" to "мая",
        "06" to "июня", "07" to "июля", "08" to "августа", "09" to "сентября", "10" to "октября", "11" to "ноября", "12" to "декабря")

    val dateList = digital.split(".")
    return when {
        dateList[1] in months -> String.format("%02d %s %02d", dateList[0], months[dateList[1]], dateList[2])
        else -> ""
    }
}

/**
 * Задача 5
 *
 * Строка состоит из набора слов, отделённых друг от друга одним пробелом.
 * Определить, имеются ли в строке повторяющиеся слова, идущие друг за другом.
 * Слова, отличающиеся только регистром, считать совпадающими.
 * Вернуть индекс начала первого повторяющегося слова, или -1, если повторов нет.
 * Пример: "Он пошёл в в школу" => результат 9 (индекс первого 'в')
 */
fun firstDuplicateIndex(str: String): Int = TODO()

/*
  НЕМНОГО ПРО ВЕЩЕСТВЕННЫЕ ЧИСЛА
  Вещественные числа хранятся в памяти в так называемом экспоненциальном формате M * 2^E.
    При этом часть бит выделяется на хранение мантиссы M (она находится в ограниченном диапазоне, обычно от 0.5 до 1),
    а другая часть бит - на хранение порядка E. Как мантисса, так и порядок хранятся в двоичной системе счисления,
    причём один бит всегда выделяется под знак.

  В Котлине имеется два вещественных типа. Один из них, уже известный нам Double, занимает в памяти восемь байт.
    При этом 53 бита выделяется на мантиссу, а 11 бит на порядок.
    Более короткий тип Float занимает четыре байта: 24 бита на мантиссу и 8 бит на порядок.

  Вещественные литералы по умолчанию имеют тип Double. Для того, чтобы создать литерал типа Float,
    необходимо использовать суффикс F:

  val f1: Float = 1.0  // Error!
  val f2: Float = 1.0F // OK!
  Тип Double является рекомендуемым для хранения вещественных чисел.
  Тип Float следует использовать, если чисел требуется много, а его точности достаточно.

 */



