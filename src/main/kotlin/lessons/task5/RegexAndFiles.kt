package lessons.task5

import java.io.File


/**
 * Пример рекурсивной функции
 */
fun foo(n: Int): Int {
    return when (n) {
        1 -> 1
        2 -> 3
        else -> foo(n-1) * n + foo(n-2) * (n - 1)
    }
}

fun main() {
    println(foo(5))
}





/*

  Регулярные выражения в Котлине

  Для описания регулярных выражений в Котлине используется тип Regex.
    Для создания регулярного выражения следует вызвать его конструктор, например Regex("KotlinAsFirst").
    Второй способ создания регулярного выражения — вызов функции toRegex() на строке-получателе,
    например "KotlinAsFirst".toRegex().

  При создании регулярных выражений вместо обычных строк в двойных кавычках рекомендуется использовать так
    называемые raw string literals (необработанные строки). Перед и после такого литерала должны стоять три двойных
    кавычки. Внутри необработанных строк не применяется экранирование, что позволяет применять специфичные для
    регулярных выражений символы без дополнительных ухищрений. Например: Regex("""x|\+|-|\*|/|\(|\)|\d+?| +?""") —
    задаёт выражение x, или +, или -, или …, или число, или любое количество пробелов. Без тройных кавычек нам
    пришлось бы дважды записать каждый из \.

  Для анализа результата поиска применяется тип MatchResult, который можно получить, вызвав find на регулярном
    выражении-получатале: Regex("""…""").find(string, startIndex). find ищет первое вхождение регулярного выражения
    в строку string, начиная с индекса startIndex (по умолчанию — 0). Если вхождений регулярного выражения не
    найдено, результат find равен null.

  Regex("""…""").findAll(string, startIndex) ищет ВСЕ вхождения регулярного выражения,
    которые после этого можно перебрать с помощью цикла for.


  Тип MatchResult включает в себя следующие свойства:

  *    result.value — подстрока исходной строки, с которой совпало регулярное выражение (совпадение)
  *    result.range — интервал индексов символов, в котором было найдено совпадение
  *    result.groupValues — список строк, 0-й элемент которого содержит всё регулярное выражение, а последующие содержат
         значения групп поиска из регулярного выражения (то есть размер списка равен числу групп поиска в выражении + 1)

  Некоторые другие полезные методы, связанные:

  *    Regex("""…""").replace("MyString", "Replacement") — находит в данной строке все вхождения регулярного выражения
         и заменяет их на `"Replacement"
  *    "MyString".contains(Regex("""…""")) — есть ли в данной строке хоть одно вхождение регулярного выражения
  *    Regex("""…""").containsMatchIn("MyString") — то же самое, но в другом порядке
  *    "MyString".matches(Regex("""…""")) — соответствует ли данная строка данному регулярному выражению (полностью)
  *    Regex("""…""").matches("MyString") — то же самое, но в другом порядке
  *    Regex("""…""").matchEntire("MyString") — то же самое, но возвращает MatchResult?
  *    Regex("""…""").split("MyString") — деление строки на части с использованием заданного регулярного выражения
         как разделителя
 */

/**
 * Задача 1
 *
 * Перевести число roman, заданное в римской системе счисления,
 * в десятичную систему и вернуть как результат.
 * Римские цифры: 1 = I, 4 = IV, 5 = V, 9 = IX, 10 = X, 40 = XL, 50 = L,
 * 90 = XC, 100 = C, 400 = CD, 500 = D, 900 = CM, 1000 = M.
 * Например: XXIII = 23, XLIV = 44, C = 100
 *
 * Вернуть -1, если roman не является корректным римским числом
 */

fun counterTranslate(number: Char): Int {
    var result = 0
        when (number) {
            'I' -> result += 1
            'V' -> result += 5
            'X' -> result += 10
            'L' -> result += 50
            'C' -> result += 100
            'D' -> result += 500
            'M' -> result += 1000
        }
    return result
}

fun fromRoman(roman: String): Int {
    val digits = listOf<Char>('I', 'V', 'X', 'L', 'C', 'D', 'M')
    var index = 0
    var result = 0
    if (!roman.matches(Regex("""[IVXLCDM]+"""))) return -1
    while (index + 1 < roman.length) {
        if (digits.indexOf(roman[index]) >= digits.indexOf(roman[index + 1] )) {
            result += counterTranslate(roman[index])
            index += 1
        }
        else {
            result += counterTranslate(roman[index + 1] ) - counterTranslate(roman[index])
            index += 2
        }
    }
    if (index == roman.lastIndex) {
        result += counterTranslate(roman[index])
    }

    return result
}


/**
 * Задача 2
 *
 * В строке представлено выражение вида "2 + 31 - 40 + 13",
 * использующее целые положительные числа, плюсы и минусы, разделённые пробелами.
 * Наличие двух знаков подряд "13 + + 10" или двух чисел подряд "1 2" не допускается.
 * Вернуть значение выражения (6 для примера).
 * Про нарушении формата входной строки бросить исключение IllegalArgumentException
 */
fun plusMinus(expression: String): Int {
    if (!expression.matches(Regex("""^((\d+ [+-] )+\d+)|\d+$"""))) {
        throw IllegalArgumentException(expression)
    }
    val parts = Regex(""" """).split(expression)
    var result = parts[0].toInt()
    var counter = 1
    while (counter < parts.size) {
        result += parts[counter + 1].toInt() *
                when (parts[counter].trim()) {
                    "+" -> 1
                    else -> -1
                }
        counter += 2
    }
    return result
}





// ФАЙЛЫ!


/*

  За занавесом: чтение из файла

  Пакет java.io позволяет работать с файлами на трёх разных уровнях:

  1. Уровень отдельных байт. В этом случае файл воспринимается как массив или, точнее, как поток байт.
       Поток, в отличие от массива, можно только перебирать, с сильно ограниченными возможностями по возвращению назад.
       Для этой цели имеется тип java.io.InputStream.

  2. Уровень символов. В этом случае файл воспринимается уже как поток символов типа Char, то есть каждые несколько
       байт файла превращаются в определённый символ — с учётом заданной кодировки файла. Для этой цели имеется
       тип java.io.InputStreamReader, который внутри себя использует InputStream для чтения байт.

  3. Уровень строк. На этом уровне файл воспринимается как набор строк String, составленных из символов по определённым
       правилам — чаще всего используется разделение по отдельным строкам файла. Эту роль выполняет
       тип java.io.BufferedReader, использующий внутри себя InputStreamReader для чтения символов.

  При программировании на Java каждый из этих объектов приходится создавать отдельно — вначале InputStream,
    потом InputStreamReader и, наконец, BufferedReader. Библиотека Котлина позволяет создать любой из этих объектов
    сразу, используя файл-получатель:

  *  file.inputStream() создаёт байтовый поток.
  *  file.reader() создаёт читатель символов, используя кодировку по умолчанию.
       file.reader(Charset.forName("CP1251")) создаёт писатель с заданной кодировкой (в данном случае CP1251).
  * Наконец, file.bufferedReader() создаёт буферизованный читатель строк. Опять-таки, может быть задана нужная
       кодировка, иначе используется кодировка по умолчанию.

  Набор функций у данных трёх объектов различается. У всех у них есть функция close(), закрывающая исходный файл
    в конце работы с потоком. Также, у них имеется функция высшего порядка use { … }, выполняющая описанные в лямбде
    действия и закрывающая файл в конце своей работы автоматически.

 */
/**
 * Например
 */

fun alignFile(inputName: String, lineLength: Int, outputName: String) {
    File(outputName).bufferedWriter().use {
        var currentLineLength = 0
        for (line in File(inputName).readLines()) {
            if (line.isEmpty()) {
                it.newLine()
                if (currentLineLength > 0) {
                    it.newLine()
                    currentLineLength = 0
                }
                continue
            }
            for (word in line.split(" ")) {
                if (currentLineLength > 0) {
                    if (word.length + currentLineLength >= lineLength) {
                        it.newLine()
                        currentLineLength = 0
                    } else {
                        it.write(" ")
                        currentLineLength++
                    }
                }
                it.write(word)
                currentLineLength += word.length
            }
        }
    }
}

/*
  Здесь исходный BufferedWriter в лямбде становится параметром it. Заметим, что при использовании use исходный файл
    будет закрыт как при корректном завершении функции, так и при возникновении исключения.

  Кроме этого, каждый объект обладает своими методами для чтения информации:

  1.  inputStream.read() читает из InputStream очередной байт, возвращая его в виде результата типа Int.
        Если файл закончен, результат этой функции будет -1. inputStream.read(byteArray) читает сразу несколько байт,
        записывая их в массив байт (число прочитанных байт равно размеру массива).
        inputStream.read(byteArray, offset, length) записывает в byteArray length байт, начиная с индекса offset.

  2.  reader.read() читает из InputStreamReader очередной символ, возвращая его в виде результата типа Int.
        Здесь используется именно Int, а не Char, так как, во-первых, символ в общем случае может не поместиться в
        двухбайтовые тип и, во-вторых, чтобы вернуть -1 в случае неудачи. Есть аналогичные методы для чтения
        символьного массива (НЕ строки) с возможным указанием смещения и числа символов — см. выше про байтовый массив.

  3.  bufferedReader.readLine() читает из BufferedReader очередную строку (до перевода строки).
        bufferedReader.readLines() читает сразу же все строки. Есть ряд других методов для работы
        со строками по отдельности.

  Следует отметить, что все функции чтения информации могут бросить исключение IOException в том случае,
    если чтение по какой-либо причине невозможно (например, если файл не существует или недоступен).


  В примере, мы вообще не создавали bufferedReader, а использовали функцию file.readLines(). Она создаёт bufferedReader
    внутри себя и обращается к его функции readLines(). После чтения последней строки файл закрывается. Вариант вызова
    file.readLines(charset) позволяет дополнительно указать кодировку, в которой следует читать файл.
    Есть и другие варианты высокоуровневых функций чтения файла:

  1.  file.forEachLine { line → … }. Эта функция высшего порядка предполагает чтение строк файла по одной, и выполнение
        операции, указанной в лямбде (…) для каждой из этих строк. Достоинство такого подхода в том, что здесь мы не
        храним в памяти весь список строк из файла, как делает file.readLines(). Это может быть важно, если размер
        файла большой. С другой стороны, подобный вариант предполагает обработку строк по очереди, от предыдущей к
        следующей, и не обеспечивает никакой возможности возврата к уже обработанной строке.
        Вариант вызова file.forEachLine(charset) { line → … } позволяет дополнительно указать кодировку.

  2.  file.useLines { lineSequence → … }. Лямбда в этой функции высшего порядка работает с последовательностью строк
        файла lineSequence, тип которой Sequence<String>. Тип Sequence напоминает типы из библиотеки коллекций Iterable и
        Collection, последовательность строк можно перебрать с помощью цикла for, на ней можно вызывать ряд функций
        высшего порядка — такие, как map, filter, forEach и так далее. Особенность функционирования последовательностей
        состоит в том, что они ленивы. Благодаря этому многие операции с последовательностями — в частности, map и
        filter — по факту не приводят к чтению их элементов (из файла или, в общем случае, из другого источника).

 */

/*
  За занавесом: запись в файл


  Запись в файл использует те же три уровня: байты OutputStream, символы OutputStreamWriter и строки BufferedWriter.
    Для записи байт либо символов используются функции write, аргументом которых может являться целое число
    (в котором хранится байт или код символа) или массив (опять-таки байт или символов). Эти функции не имеют результата
     и бросают IOException, если файл недоступен для записи. BufferedWriter может использовать функцию write также для
     записи строк. Как и все три вида потоков чтения, потоки записи необходимо закрывать после использования с помощью
     close() или use { … }.

  Сверх этого, для записи часто используется так называемый поток печати PrintStream. В Котлине его можно создать из
    файла, используя функцию file.printStream(). Поток печати расширяет обычный байтовый поток рядом
    дополнительных возможностей:

  1.  printStream.println(…) — вывод заданной строки или строкового представления с последующим переходом на новую строку.

  2.  printStream.print(…) — то же, но без перехода на новую строку.

  3.  printStream.format(formatString, …) — форматированный вывод.

 */

/**
 * Задача 3
 *
 * В русском языке, как правило, после букв Ж, Ч, Ш, Щ пишется И, А, У, а не Ы, Я, Ю.
 * Во входном файле с именем inputName содержится некоторый текст на русском языке.
 * Проверить текст во входном файле на соблюдение данного правила и вывести в выходной
 * файл outputName текст с исправленными ошибками.
 *
 * Регистр заменённых букв следует сохранять.
 *
 * Исключения (жюри, брошюра, парашют) в рамках данного задания обрабатывать не нужно
 *
 */

// сделать так чтобы оно работало
// val test = Regex("""[ЖжЧчШшЩщ]""").findAll(line)
// Regex("""[ЖжЧчШшЩщ]""").replace(line, {test} -> )

fun sibilants(inputName: String, outputName: String) {
    val wordsToSkip = setOf<String>("жюри", "брошюра", "парашют")
    File(outputName).bufferedWriter().use { writer ->
        for (line in File(inputName).readLines()) {
            val reg = Regex("""[ЖжЧчШшЩщ][ЫыЯяЮю]""").replace(line) { tes ->
                val preResult = tes.groupValues.last()
                val res = StringBuilder()
                res.append(preResult[0])
                res.append(when (preResult[1]) {
                    'ы' -> 'и'; 'Ы' -> 'И'
                    'ю' -> 'у'; 'Ю' -> 'У'
                    'я' -> 'а'; else -> 'А'
                })
                res.toString()
            }
            val formatedLine = Regex("""жУри|броШУра|параШут""").replace(reg) {
                val preRes = it.groupValues.last()
                when (preRes) {
                    "жУри" -> "жЮри"
                    "броШУра" -> "броШЮра"
                    else -> "параШют"
                }
            }
            writer.write(formatedLine).also { writer.newLine() }
        }
    }
}

//            for (word in line.split(" ")) {
//                if (word in wordsToSkip) {
//                    continue
//                }
//                for (letter in word) {
//                    if (letter in lettersToCheck) {
//                        if (word[word.indexOf(letter) + 1] in lettersToReplace) {
//                            Regex("""[ыЫяЯюЮ]""").replace(word, lettersToReplace[letter].toString())
//                            it.write(line)
//                        }
//                    }
//                }
//            }
//            it.newLine()
//        }

//            Regex("""[ЖжЧчШшЩщ][ыЫяЯюЮ]""").replace(line)

/**
 * Задача 4
 *
 * Во входном файле с именем inputName содержится некоторый текст (в том числе, и на русском языке).
 * Вывести его в выходной файл с именем outputName, выровняв по центру
 * относительно самой длинной строки.
 *
 * Выравнивание следует производить путём добавления пробелов в начало строки.
 *
 *
 * Следующие правила должны быть выполнены:
 * 1) Пробелы в начале и в конце всех строк не следует сохранять.
 * 2) В случае невозможности выравнивания строго по центру, строка должна быть сдвинута в ЛЕВУЮ сторону
 * 3) Пустые строки не являются особым случаем, их тоже следует выравнивать
 * 4) Число строк в выходном файле должно быть равно числу строк во входном (в т. ч. пустых)
 *
 */
fun centerFile(inputName: String, outputName: String) {
    var maxSizeOfStr = 0
    for (line in File(inputName).readLines()) {
        val trimedLine = line.trim()
        if (trimedLine.length > maxSizeOfStr)
            maxSizeOfStr = trimedLine.length
    }
    File(outputName).bufferedWriter().use {
        for (line in File(inputName).readLines()) {
            val alignment = (maxSizeOfStr - line.trim().length) / 2
            it.write(" ".repeat(alignment))
            it.write(line.trim())
            it.newLine()
        }
    }
}


